import React from 'react'
import Enzyme, { shallow } from 'enzyme'
import Adapter from 'enzyme-adapter-react-16'
import { spy } from 'sinon'
import { withValidationAndTransition, NumberField } from '..'

Enzyme.configure( { adapter: new Adapter() } )

const Type = withValidationAndTransition( NumberField )
const testComponent = (
  <Type
    title="test"
    registerValidationError={() => 1}
    fieldIndex={0}
    min={0}
  />
)

describe( 'withValidationAndTransitions', () => {
  test( 'is exported by src/index.js', () => {
    expect( withValidationAndTransition ).toBeTruthy()
  } )

  test( 'recognises validation props and adds to this.checks on mount', () => {
    const wrapper = shallow( testComponent )
    expect( wrapper.instance().checks.min ).toBeTruthy()
  } )

  test( 'registers validation errors on mount', () => {
    const registerValidationErrorSpy = spy()
    shallow( <Type title="test" registerValidationError={registerValidationErrorSpy} /> )
    expect( registerValidationErrorSpy.calledOnce ).toBeTruthy()
  } )

  describe( 'addValidationChecks', () => {
    test( 'updates this.checks with new checks', () => {
      const component = ( testComponent )
      const wrapper = shallow( component )
      wrapper.instance().addValidationChecks(
        { max: { func: () => 1, test: 1 }, isNum: { func: () => 1, test: 1 } },
      )
      expect( wrapper.instance().checks.min ).toBeTruthy()
      expect( wrapper.instance().checks.max ).toBeTruthy()
      expect( wrapper.instance().checks.isNum ).toBeTruthy()
    } )
    test( 'calls registerValidationError', () => {
      const registerValidationErrorSpy = spy()
      const wrapper = shallow( <Type title="test" registerValidationError={registerValidationErrorSpy} /> )
      // reset history incase lifecycle methods use this method
      registerValidationErrorSpy.resetHistory()
      wrapper.instance().addValidationChecks( { check: { func: () => 1, test: 1 } } )
      expect( registerValidationErrorSpy.calledOnce ).toBeTruthy()
    } )
  } )

  describe( 'updateValidationChecks', () => {
    test( 'updates this.checks with new checks', () => {
      const wrapper = shallow( testComponent )
      wrapper.instance().addValidationChecks(
        { max: { func: () => 1, test: 1 } },
      )

      expect( wrapper.instance().checks.max.func() ).toEqual( 1 )

      wrapper.instance().addValidationChecks(
        { max: { func: () => 0, test: 1 } },
      )
      expect( wrapper.instance().checks.min ).toBeTruthy()
      expect( wrapper.instance().checks.max.func() ).toEqual( 0 )
    } )

    test( 'calls registerValidationError with new errors generated by updated checks', () => {
      const registerValidationErrorSpy = spy()
      const wrapper = shallow( <Type title="test" registerValidationError={registerValidationErrorSpy} /> )
      // reset history incase lifecycle methods use this method
      registerValidationErrorSpy.resetHistory()
      wrapper.instance().updateValidationChecks( { check: { func: () => 1, test: 1 } } )
      expect( registerValidationErrorSpy.calledOnce ).toBeTruthy()
    } )
  } )
} )
